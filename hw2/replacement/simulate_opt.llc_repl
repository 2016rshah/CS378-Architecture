#include "cache.h"
#include "ooo_cpu.h"
#include <fstream>
#include <unordered_map>

using namespace std;

// the trace file of cache accesses
ifstream trace_file;
vector<uint64_t> trace; 
int trace_index;

uint64_t address;
    trace_file >> address;

/* returns the trace name, with .txt appended */
char *get_trace_name() {
    int i;
    int len = strlen(ooo_cpu[0].trace_string);
    for (i = len-1; i >= 0 && ooo_cpu[0].trace_string[i] != '/'; i--) ;
    char *result = new char[len-i-6];
    memcpy(result, &(ooo_cpu[0].trace_string[i+1]), len-i-10);
    strcpy(result+len-i-10, ".txt");
    return result;
}

/* initialize cache replacement state */
void CACHE::llc_initialize_replacement()
{
    cout << "initializing OPT simulator ..." << endl;

    /* open the cache reference trace file */
    char *trace = get_trace_name();
    const char *base = "/u/matthewp/traces/";
    char *filename = new char[strlen(base)+strlen(trace)+1];
    strcpy(filename, base);
    strcpy(&(filename[strlen(base)]), trace);
    delete trace;
    cout << "reading cache references from: " << filename << endl;
    trace_file = ifstream(filename);

    // put your own initialization code here

    // use trace_file to create an array, initialize an index counter into the array which represents where we are in the program
    trace_index = 0; 
    while(trace_file.good()) {
        uint64_t address;
        trace_file >> address;
        trace.push_back(address);
        trace_index++;
    }
}

/* find a cache block to evict
 * return value should be 0 ~ 15 (corresponds to # of ways in cache) 
 * current_set: an array of BLOCK, of size 16 */
uint32_t CACHE::llc_find_victim(uint32_t cpu, uint64_t instr_id, uint32_t set, const BLOCK *current_set, uint64_t pc, uint64_t full_addr, uint32_t type)
{
    /* don't modify this code or put anything above it;
     * if there's an invalid block, we don't need to evict any valid ones */
    for (int way = 0; way < LLC_WAY; way++) {
        if (current_set[way].valid == false) {
            return way;
        }
    }

    // your eviction policy goes here

    // for loop through the possible victims and for loop forward in the trace array to find the max value you have to increment before you find the same thing. Return that. 
    int max_interval = 0;
    int max_interval_way = 0;
    for(int current_way = 0; i < LLC_WAY; current_way++) {
        int current_interval = 0;
        uint64_t target_addr = current_set[current_way].address; // block address
        uint64_t curr_addr = trace[trace_index + current_interval] >> LOG2_BLOCK_SIZE;
        while(target_addr != curr_addr) {
            current_interval++;
            curr_addr = trace[trace_index + current_interval] >> LOG2_BLOCK_SIZE;
        }
        if(current_interval > max_interval) {
            max_interval = current_interval;
            max_interval_way = current_way;
        }
    }
    return max_interval_way;
}

/* called on every cache hit and cache fill */
void CACHE::llc_update_replacement_state(uint32_t cpu, uint32_t set, uint32_t way, uint64_t full_addr, uint64_t pc, uint64_t victim_addr, uint32_t type, uint8_t hit, uint64_t latency, uint64_t effective_latency)
{
    /* don't modify this code or put anythin above it;
     * OPT doesn't care about writebacks */
    if (type == WRITEBACK)
        return;

    // your code goes here

    // increment the index counter because we have incremented one value from where we are in the trace file
    trace_index++; // will writebacks be recorded in the trace? if so I'll need to ignore the warning and increment the value above that other line of code
}

/* called at the end of the simulation */
void CACHE::llc_replacement_final_stats()
{
    // close the trace file
    trace_file.close();

    // your code goes here

}
